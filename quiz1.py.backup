import time
import os

# Import chapter question modules
from chapter1_questions import get_chapter_1_questions
from chapter2_questions import get_chapter_2_questions
from chapter3_questions import get_chapter_3_questions
from chapter4_questions import get_chapter_4_questions

# ============================================================================
# CHAPTER CONFIGURATION
# ============================================================================
# To add a new chapter:
# 1. Create a new chapterX_questions.py file with get_chapter_X_questions() function
# 2. Import it above
# 3. Add an entry to the CHAPTERS dictionary below
# ============================================================================
CHAPTERS = {
    1: {
        'number': 1,
        'title': 'Chapter 1',
        'function': get_chapter_1_questions
    },
    2: {
        'number': 2,
        'title': 'Chapter 2',
        'function': get_chapter_2_questions
    },
    3: {
        'number': 3,
        'title': 'Chapter 3',
        'function': get_chapter_3_questions
    },
    4: {
        'number': 4,
        'title': 'Chapter 4',
        'function': get_chapter_4_questions
    }
}

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def display_header(chapter_selection):
    print("=" * 80)
    print("SYSC 4810: Introduction to Network and Software Security")

    if chapter_selection == "0":
        # All chapters
        chapter_titles = " & ".join([str(ch) for ch in sorted(CHAPTERS.keys())])
        print(f"Chapters {chapter_titles} Combined Quiz - Fall 2024")
    else:
        # Single chapter
        chapter_num = int(chapter_selection)
        if chapter_num in CHAPTERS:
            print(f"{CHAPTERS[chapter_num]['title']} Quiz - Fall 2024")

    print("=" * 80)
    print("Time Limit: 75 Minutes")
    print("Total Points: 100")
    print("=" * 80)
    print()

def countdown_timer(seconds):
    """Display live timer"""
    mins = seconds // 60
    secs = seconds % 60
    print(f"â° Time remaining: {mins:02d}:{secs:02d}", end=" | ")

def show_feedback(user_answer, correct_answer, is_correct, points_earned, total_points, explanation=""):
    """Show immediate feedback after each answer"""
    print("\n" + "-" * 80)
    if is_correct:
        print(f"âœ“ CORRECT! (+{points_earned} points)")
    else:
        print(f"âœ— INCORRECT (0 points)")
        print(f"Your answer: {user_answer}")
        print(f"Correct answer: {correct_answer}")
    
    if explanation:
        print(f"\nðŸ’¡ Explanation: {explanation}")
    
    print("-" * 80)
    input("\nPress ENTER to continue...")

def get_chapter_1_questions():
    return {
        # SECTION 1: MULTIPLE CHOICE (2 points each)
        "section1": {
            "title": "Section 1: Multiple Choice (2 points each)",
            "questions": [
                {
                    "num": 1,
                    "question": "The CIA Triad consists of which three security objectives?",
                    "options": {
                        "A": "Confidentiality, Integrity, Authentication",
                        "B": "Confidentiality, Integrity, Availability",
                        "C": "Confidentiality, Information disclosure, Availability",
                        "D": "Confidentiality, Integrity, Accountability"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "The CIA Triad is the foundation of security: Confidentiality (data access control), Integrity (data accuracy), and Availability (resource accessibility)."
                },
                {
                    "num": 2,
                    "question": "Which of the following is an example of a passive attack?",
                    "options": {
                        "A": "Modifying messages sent between Alice and Bob",
                        "B": "Replaying authentication sequences",
                        "C": "Traffic analysis - observing frequency and length of messages",
                        "D": "Suppressing messages directed to a security audit service"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Passive attacks observe/monitor data without altering it. Traffic analysis observes patterns. Active attacks modify, suppress, or replay data."
                },
                {
                    "num": 3,
                    "question": "In asymmetric encryption, which key does Alice use to encrypt a message to Bob?",
                    "options": {
                        "A": "Bob's public key",
                        "B": "Bob's private key",
                        "C": "Alice's private key",
                        "D": "The shared secret key"
                    },
                    "answer": "A",
                    "points": 2,
                    "explanation": "For confidentiality in asymmetric encryption: encrypt with recipient's PUBLIC key, decrypt with recipient's PRIVATE key. Only Bob can decrypt with his private key."
                },
                {
                    "num": 4,
                    "question": "For digital signature generation, which key does Bob (the signer) use?",
                    "options": {
                        "A": "Bob's public key",
                        "B": "Bob's private key",
                        "C": "Alice's public key",
                        "D": "Alice's private key"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Digital signatures: Sign with sender's PRIVATE key, verify with sender's PUBLIC key. This proves the message came from Bob."
                },
                {
                    "num": 5,
                    "question": "Risk is calculated using which formula?",
                    "options": {
                        "A": "R = T + V",
                        "B": "R = T Ã— V Ã— C",
                        "C": "R = P Ã— C",
                        "D": "R = V Ã· C"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Risk = Probability Ã— Consequence. Some sources also show R = TÃ—VÃ—C (Threat Ã— Vulnerability Ã— Cost), but the lecture primarily used R = PÃ—C."
                },
                {
                    "num": 6,
                    "question": "Which is NOT a component of adversary modeling?",
                    "options": {
                        "A": "Objectives (target assets/systems)",
                        "B": "Methods (attack techniques)",
                        "C": "Countermeasures",
                        "D": "Motivation"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Adversary modeling includes: Objectives, Methods, Capabilities, and Motivation. Countermeasures are part of the defense/security design, not adversary modeling."
                },
                {
                    "num": 7,
                    "question": "In the STRIDE threat modeling framework, what does the 'R' stand for?",
                    "options": {
                        "A": "Reconnaissance",
                        "B": "Repudiation",
                        "C": "Replay",
                        "D": "Request forgery"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "STRIDE: Spoofing, Tampering, Repudiation, Information disclosure, Denial of service, Escalation of privilege."
                },
                {
                    "num": 8,
                    "question": "Which security design principle states that systems should deny access by default?",
                    "options": {
                        "A": "P1: Simplicity-and-necessity",
                        "B": "P2: Safe-defaults",
                        "C": "P4: Complete-mediation",
                        "D": "P6: Least-privilege"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "P2: Safe-defaults means deny access by default, fail safe, use strong default passwords, and HTTPS by design."
                },
                {
                    "num": 9,
                    "question": "The principle 'Security by obscurity' is:",
                    "options": {
                        "A": "Recommended as a primary defense",
                        "B": "NOT recommended (violates P3: Open-design)",
                        "C": "Part of defense-in-depth",
                        "D": "Required for all systems"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "P3: Open-design principle states security should NOT rely on obscurity. Systems should be secure even if the design is public."
                },
                {
                    "num": 10,
                    "question": "Which principle requires that every access to a resource must be checked for authorization?",
                    "options": {
                        "A": "P2: Safe-defaults",
                        "B": "P3: Open-design",
                        "C": "P4: Complete-mediation",
                        "D": "P5: Isolated-compartments"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "P4: Complete-mediation means every access must be checked through authentication and authorization, every time."
                },
                {
                    "num": 11,
                    "question": "The principle of P6: Least-privilege means:",
                    "options": {
                        "A": "Users should have minimal passwords",
                        "B": "Systems should have minimal features",
                        "C": "Grant only necessary permissions (e.g., don't distribute super accounts)",
                        "D": "Use the smallest possible encryption keys"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "P6: Least-privilege means give only the minimum permissions needed. Example: don't distribute super/admin accounts unnecessarily."
                },
                {
                    "num": 12,
                    "question": "P8: Small-trusted-bases advocates for:",
                    "options": {
                        "A": "Using only small software packages",
                        "B": "Microkernel architectures and separating algorithms from secrets",
                        "C": "Limiting the number of users",
                        "D": "Small network designs"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "P8: Small-trusted-bases favors microkernel architectures (vs monolithic) and separating crypto algorithms from secrets. Smaller trusted base = easier to verify."
                },
                {
                    "num": 13,
                    "question": "Which principle states that designs should align with users' mental models?",
                    "options": {
                        "A": "P9: Time-tested tools",
                        "B": "P10: Least surprise",
                        "C": "P11: User-buy-in",
                        "D": "P12: Sufficient-work-factor"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "P10: Least surprise means align with users' mental models, tailor to target users, make systems intuitive to avoid mistakes."
                },
                {
                    "num": 14,
                    "question": "P13: Defence-in-depth means:",
                    "options": {
                        "A": "Bury critical systems underground",
                        "B": "Use only the strongest single defense mechanism",
                        "C": "Place defense mechanisms at each stage to avoid single points of failure",
                        "D": "Focus only on network perimeter security"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "P13: Defence-in-depth means layered security - place defenses at each stage, avoid single points of failure. Also includes defense-in-breadth."
                },
                {
                    "num": 15,
                    "question": "P15: Data-type-verification requires:",
                    "options": {
                        "A": "Sanitizing all input regardless of source",
                        "B": "Only validating external inputs",
                        "C": "Only checking data types at compile time",
                        "D": "Trusting internal data sources"
                    },
                    "answer": "A",
                    "points": 2,
                    "explanation": "P15: Data-type-verification means sanitize ANY input, no matter where it came from. Never trust any input source."
                },
                {
                    "num": 16,
                    "question": "Which statement about testing and security is TRUE?",
                    "options": {
                        "A": "Complete security testing is possible with enough time",
                        "B": "Security testing is necessarily incomplete",
                        "C": "Passing all tests proves a system is secure",
                        "D": "Black box testing can find all vulnerabilities"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Testing is necessarily incomplete - we cannot test for unknown/unforeseen attacks. The universe of potential exploits is unknown."
                },
                {
                    "num": 17,
                    "question": "Security is described as 'unobservable' because:",
                    "options": {
                        "A": "Security mechanisms are always hidden",
                        "B": "We can observe security directly through metrics",
                        "C": "We cannot prove the absence of vulnerabilities",
                        "D": "Security testing is not allowed"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Security is unobservable - we cannot prove absence of vulnerabilities (like proving all swans are white). We only observe when security fails."
                },
                {
                    "num": 18,
                    "question": "Which is a reason why security is hard?",
                    "options": {
                        "A": "Defenders must protect all vulnerabilities; attackers need only find one",
                        "B": "Attackers follow strict rules and protocols",
                        "C": "Software complexity has decreased over time",
                        "D": "All developers receive extensive security training"
                    },
                    "answer": "A",
                    "points": 2,
                    "explanation": "Defender-attacker asymmetry: defenders must protect ALL attack surfaces, but attackers only need to find ONE weakness."
                },
                {
                    "num": 19,
                    "question": "The Internet threat model traditionally assumes:",
                    "options": {
                        "A": "End-points are trustworthy; communication links are under attacker control",
                        "B": "Both end-points and links are under attacker control",
                        "C": "End-points are compromised; links are secure",
                        "D": "Everything is secure by default"
                    },
                    "answer": "A",
                    "points": 2,
                    "explanation": "Traditional Internet threat model: end-points (client/server) are trusted, but communication links are insecure (attacker can eavesdrop, modify). This follows the historic cryptographer's model."
                },
                {
                    "num": 20,
                    "question": "Which is NOT one of the 'Why Security is Hard' factors?",
                    "options": {
                        "A": "Intelligent, adaptive adversary",
                        "B": "Defender-attacker asymmetry",
                        "C": "Simple, unchanging software",
                        "D": "User non-compliance"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Software COMPLEXITY (not simplicity) is a major reason security is hard. Complexity is the enemy of security. Rapid pace of evolution also makes it harder."
                }
            ]
        },
        
        # SECTION 2: TRUE/FALSE (1 point each)
        "section2": {
            "title": "Section 2: True/False (1 point each)",
            "questions": [
                {
                    "num": 21,
                    "question": "Authentication provides assurance that data or software is genuine.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "Authentication verifies identity/genuineness - that a principal, data, or software is what it claims to be."
                },
                {
                    "num": 22,
                    "question": "Authorization is the same as authentication.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Authentication = verifying identity ('who are you?'). Authorization = determining access rights ('what can you access?')."
                },
                {
                    "num": 23,
                    "question": "Accountability refers to the ability to identify principals responsible for past actions.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Accountability enables identifying who did what, crucial for forensics and non-repudiation."
                },
                {
                    "num": 24,
                    "question": "'Trusted' and 'trustworthy' mean the same thing in security contexts.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - 'Trusted' = HAS our confidence (we rely on it). 'Trustworthy' = DESERVES our confidence (actually secure)."
                },
                {
                    "num": 25,
                    "question": "A security policy specifies what is and is not allowed in a system.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Security policy specifies the design intent of rules and practices - what is and is not (supposed to be) allowed."
                },
                {
                    "num": 26,
                    "question": "A threat is the same as an attack.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Threat = potential/circumstances that might cause harm. Attack = deliberate execution of steps to cause a security violation."
                },
                {
                    "num": 27,
                    "question": "Controls and countermeasures are terms for the same concept.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Both terms refer to mechanisms that support and enforce security policies."
                },
                {
                    "num": 28,
                    "question": "Outsider attacks are launched without any prior special access to the target network.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Outsider attacks have no prior access. Insider attacks originate from parties with starting advantage/access."
                },
                {
                    "num": 29,
                    "question": "In qualitative risk assessment, C represents 'Cost or impact' and P represents 'Probability.'",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - In the risk matrix shown, C = cost/impact and P = probability, resulting in risk levels 1-5."
                },
                {
                    "num": 30,
                    "question": "Cost-benefit analysis helps with deciding security budgets.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Cost-benefit analysis weighs security investment costs against potential losses, helping budget decisions."
                },
                {
                    "num": 31,
                    "question": "Attack trees output a complete list of all possible attacks.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Attack trees produce extensive lists but usually INCOMPLETE. They help identify many attacks but cannot guarantee completeness."
                },
                {
                    "num": 32,
                    "question": "Checklists are best used as the sole method for threat modeling.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Checklists are best used as COMPLEMENTARY tools, not as the sole method. They help ensure known threats aren't overlooked but lack system-specific context."
                },
                {
                    "num": 33,
                    "question": "STRIDE's 'S' stands for 'Spoofing' - attempts to impersonate.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - S = Spoofing (impersonation of entities or things)."
                },
                {
                    "num": 34,
                    "question": "STRIDE's 'D' stands for 'Denial of service.'",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - D = Denial of service (impacting availability/quality through malicious actions)."
                },
                {
                    "num": 35,
                    "question": "Penetration testing traditionally uses white-box methods.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Pen testing TRADITIONALLY uses black-box methods. White-box pen testing increases chances of finding vulnerabilities but is not traditional."
                },
                {
                    "num": 36,
                    "question": "Certification requires third-party lab reviewing and can be costly and time-consuming.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Certification involves third-party evaluation, is costly/time-consuming, and requires re-certification even for small changes."
                },
                {
                    "num": 37,
                    "question": "Security evaluation is needed only once during a product's lifecycle.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Security analysis should begin early and continue iteratively throughout the product lifecycle, not just once."
                },
                {
                    "num": 38,
                    "question": "P1: Simplicity-and-necessity suggests minimizing attack surfaces.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - P1 advocates minimal installs, minimal functionality to minimize attack surfaces."
                },
                {
                    "num": 39,
                    "question": "P7: Modular-design favors monolithic kernel architectures.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - P7 favors object-oriented and fine-grained designs. The Tanenbaum vs Torvalds debate: P8 favors MICROkernel, not monolithic."
                },
                {
                    "num": 40,
                    "question": "P17: Trust-anchor-justification warns that trust anchors are dangerous and their trustworthiness must be ensured.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Trust anchors are dangerous single points of trust. Their trustworthiness must be carefully justified and verified."
                }
            ]
        },
        
        # SECTION 3: SCENARIO-BASED (3 points each)
        "section3": {
            "title": "Section 3: Scenario-Based Questions (3 points each)",
            "questions": [
                {
                    "num": 41,
                    "question": "Consider a firewall rule table. An external client (10.2.4.56) sends a UDP packet from port 1234 to an internal Kerberos server (172.24.31.1) on port 88. A rule states: 'In, External, Internal, UDP, >1023, 88, Permit.' Will this packet be permitted or denied?",
                    "options": {
                        "A": "Permitted",
                        "B": "Denied",
                        "C": "Depends on other rules",
                        "D": "Cannot determine"
                    },
                    "answer": "A",
                    "points": 3,
                    "explanation": "PERMITTED - The packet matches: Direction=In, Src=External (10.2.4.56), Dest=Internal (172.24.31.1), Protocol=UDP, Src Port=1234 (>1023), Dest Port=88. Rule action: Permit."
                },
                {
                    "num": 42,
                    "question": "In a house security policy: 'Only family members may remove objects.' An unlocked back door is a _______, and a stranger entering through it is an _______.",
                    "options": {
                        "A": "Vulnerability; Attack",
                        "B": "Threat; Vulnerability",
                        "C": "Attack; Security violation",
                        "D": "Security violation; Threat"
                    },
                    "answer": "A",
                    "points": 3,
                    "explanation": "Unlocked door = VULNERABILITY (weakness that can be exploited). Stranger entering and taking items = ATTACK (deliberate execution exploiting the vulnerability)."
                },
                {
                    "num": 43,
                    "question": "A web application uses a list of one-time passwords. A phishing site asks for multiple passwords from the list. This threat modeling failure demonstrates:",
                    "options": {
                        "A": "Successful defense-in-depth",
                        "B": "Failure to consider all attack vectors",
                        "C": "Proper adversary modeling",
                        "D": "Effective security policy"
                    },
                    "answer": "B",
                    "points": 3,
                    "explanation": "This is an example of FAILED threat modeling - the designers didn't anticipate an attacker asking for MULTIPLE passwords from the list (via phishing), only anticipated single password leaks."
                },
                {
                    "num": 44,
                    "question": "Alice wants to send Bob a confidential message. Which encryption approach and key should she use?",
                    "options": {
                        "A": "Symmetric encryption with a shared secret key",
                        "B": "Asymmetric encryption with Alice's private key",
                        "C": "Asymmetric encryption with Bob's public key",
                        "D": "Either A or C"
                    },
                    "answer": "D",
                    "points": 3,
                    "explanation": "For CONFIDENTIALITY, both work: (A) Symmetric with shared secret key, or (C) Asymmetric with Bob's public key. Both ensure only Bob can decrypt. (B) would be for authentication/signatures, not confidentiality."
                },
                {
                    "num": 45,
                    "question": "An online bank disables transfers to prevent account compromise, but attackers purchase the bank's own products with stolen funds. This is an example of:",
                    "options": {
                        "A": "Successful threat modeling",
                        "B": "Failed threat modeling - wrong threats prioritized",
                        "C": "Effective risk mitigation",
                        "D": "Proper defense-in-depth"
                    },
                    "answer": "B",
                    "points": 3,
                    "explanation": "FAILED threat modeling - the bank focused on the wrong threat (transfers) but didn't consider attackers could still use funds to buy products. Demonstrates failure to consider all attack vectors."
                }
            ]
        },
        
        # SECTION 4: SHORT ANSWER (2 points each)
        "section4": {
            "title": "Section 4: Short Answer (2 points each)",
            "questions": [
                {
                    "num": 46,
                    "question": "Name TWO attack types that are classified as ACTIVE attacks (separate with comma):",
                    "answer": ["denial of service", "replay", "masquerade", "modification"],
                    "points": 2,
                    "type": "multi_text",
                    "explanation": "Active attacks include: Denial of Service, Replay, Masquerade, Modification of Messages. (Passive attacks: Traffic Analysis, Release of Message Contents)"
                },
                {
                    "num": 47,
                    "question": "In diagram-driven threat modeling, what visual element is used to delimit trust domains?",
                    "answer": ["system gateways", "trust boundaries", "boundaries", "gateways", "rectangles"],
                    "points": 2,
                    "type": "text",
                    "explanation": "System gateways/trust boundaries are marked (often with rectangles) where system controls restrict or filter communications, delimiting trust domains."
                },
                {
                    "num": 48,
                    "question": "What does HP1: Security-by-design mean? (Brief answer)",
                    "answer": ["don't make security an independent layer", "integrate security from start", "security from design", "not added at end", "integrate from beginning"],
                    "points": 2,
                    "type": "text",
                    "explanation": "HP1: Security-by-design means do NOT make security an independent added layer at the end. Integrate security from the beginning of design."
                },
                {
                    "num": 49,
                    "question": "Name ONE way assurance is achieved:",
                    "answer": ["testing", "pen testing", "penetration testing", "formal modeling", "design practices", "sound design", "experience", "analysis", "code review"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Assurance comes from: sound design practices, testing (pen testing), formal modeling, ad hoc analysis, and heavy reliance on experience."
                },
                {
                    "num": 50,
                    "question": "According to the lecture, 'complexity is the enemy of _________.'",
                    "answer": ["security"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Complexity is the enemy of SECURITY. Software complexity makes systems harder to secure and analyze."
                }
            ]
        }
    }
def get_chapter_2_questions():
    """Returns Chapter 2 questions"""
    return {
        # SECTION 1: MULTIPLE CHOICE (2 points each)
        "section1": {
            "title": "Section 1: Multiple Choice (2 points each)",
            "questions": [
                {
                    "num": 1,
                    "question": "In symmetric encryption, the encryption key k and decryption key k' are:",
                    "options": {
                        "A": "Different keys generated independently",
                        "B": "The same key (k = k')",
                        "C": "Public and private key pairs",
                        "D": "One is derived from a hash of the other"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Symmetric encryption uses the same key for both encryption and decryption (k = k'), also called secret-key encryption."
                },
                {
                    "num": 2,
                    "question": "Which of the following is an example of a symmetric encryption algorithm?",
                    "options": {
                        "A": "RSA",
                        "B": "AES",
                        "C": "Diffie-Hellman",
                        "D": "Elliptic Curve Cryptography"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "AES (Advanced Encryption Standard) is a symmetric encryption algorithm. RSA and ECC are asymmetric, and Diffie-Hellman is for key exchange."
                },
                {
                    "num": 3,
                    "question": "For a key of size n bits, how many expected trials are needed for a brute-force attack?",
                    "options": {
                        "A": "n",
                        "B": "2^n",
                        "C": "2^(n-1)",
                        "D": "n^2"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "On average, you'd need to try half the key space, which is 2^(n-1) trials for an n-bit key."
                },
                {
                    "num": 4,
                    "question": "Which attack model involves the attacker having access to both plaintext and corresponding ciphertext?",
                    "options": {
                        "A": "Ciphertext-only attack",
                        "B": "Known-plaintext attack",
                        "C": "Chosen-plaintext attack",
                        "D": "Chosen-ciphertext attack"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Known-plaintext attack: attacker has CT-PT pairs and tries to recover unknown PT or key from another CT."
                },
                {
                    "num": 5,
                    "question": "The Vernam cipher (one-time pad) is:",
                    "options": {
                        "A": "Computationally secure",
                        "B": "Information-theoretically secure",
                        "C": "Vulnerable to known-plaintext attacks",
                        "D": "Based on RSA encryption"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "One-time pads are information-theoretically secure (unbreakable even with unlimited computing power) when used correctly."
                },
                {
                    "num": 6,
                    "question": "What is the main practical limitation of one-time pads?",
                    "options": {
                        "A": "They are too slow",
                        "B": "Key distribution and key length requirements",
                        "C": "They only work with small messages",
                        "D": "They are vulnerable to frequency analysis"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "One-time pads require keys as long as the message and secure key distribution, making them impractical for most uses."
                },
                {
                    "num": 7,
                    "question": "Electronic Code-Book (ECB) mode is considered insecure because:",
                    "options": {
                        "A": "It's too slow for modern applications",
                        "B": "Identical plaintext blocks produce identical ciphertext blocks",
                        "C": "It requires too much memory",
                        "D": "It can only encrypt small messages"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "ECB encrypts each block independently with the same key, so identical plaintext blocks produce identical ciphertext, revealing patterns."
                },
                {
                    "num": 8,
                    "question": "In CBC (Cipher-Block Chaining) mode, what is used to ensure different ciphertext for identical plaintext?",
                    "options": {
                        "A": "A counter value",
                        "B": "An initialization vector (IV)",
                        "C": "A different key for each block",
                        "D": "A hash function"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "CBC uses a random initialization vector (IV) and chains blocks together by XORing each plaintext block with the previous ciphertext block."
                },
                {
                    "num": 9,
                    "question": "Which cipher mode allows for parallel encryption and decryption?",
                    "options": {
                        "A": "CBC",
                        "B": "CTR",
                        "C": "Both A and B",
                        "D": "Neither A nor B"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "CTR (Counter) mode allows parallelization of both encryption and decryption. CBC only allows parallel decryption."
                },
                {
                    "num": 10,
                    "question": "In asymmetric encryption, to send a confidential message to Bob, Alice should encrypt with:",
                    "options": {
                        "A": "Alice's private key",
                        "B": "Alice's public key",
                        "C": "Bob's private key",
                        "D": "Bob's public key"
                    },
                    "answer": "D",
                    "points": 2,
                    "explanation": "For confidentiality: encrypt with recipient's PUBLIC key, only recipient can decrypt with their PRIVATE key."
                },
                {
                    "num": 11,
                    "question": "For n parties to communicate securely using symmetric encryption, how many keys are needed?",
                    "options": {
                        "A": "n",
                        "B": "2n",
                        "C": "n(n-1)/2",
                        "D": "n^2"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Each pair needs a unique shared key, requiring n(n-1)/2 keys. Asymmetric encryption only needs 2n keys (public/private pair per person)."
                },
                {
                    "num": 12,
                    "question": "What is the primary advantage of hybrid encryption?",
                    "options": {
                        "A": "It's more secure than pure asymmetric encryption",
                        "B": "It combines the speed of symmetric encryption with the key distribution benefits of asymmetric",
                        "C": "It uses shorter keys",
                        "D": "It doesn't require any key management"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Hybrid encryption uses asymmetric encryption to securely exchange a symmetric key, then uses faster symmetric encryption for the actual data."
                },
                {
                    "num": 13,
                    "question": "A digital signature is created by:",
                    "options": {
                        "A": "Encrypting with the sender's public key",
                        "B": "Encrypting with the sender's private key",
                        "C": "Encrypting with the recipient's public key",
                        "D": "Hashing the message"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Digital signatures: sign with sender's PRIVATE key (signing key), verify with sender's PUBLIC key (verification key)."
                },
                {
                    "num": 14,
                    "question": "Which property is NOT provided by digital signatures?",
                    "options": {
                        "A": "Data origin authentication",
                        "B": "Data integrity",
                        "C": "Confidentiality",
                        "D": "Non-repudiation"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Digital signatures provide authentication, integrity, and non-repudiation, but NOT confidentiality (anyone can verify a signature)."
                },
                {
                    "num": 15,
                    "question": "Cryptographic hash functions produce:",
                    "options": {
                        "A": "Variable-length output",
                        "B": "Fixed-length output",
                        "C": "Encrypted data",
                        "D": "Reversible transformations"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Cryptographic hash functions take arbitrary-length input and produce fixed-length output (hash value/message digest)."
                },
                {
                    "num": 16,
                    "question": "Preimage resistance (H1) means:",
                    "options": {
                        "A": "Given h, it's infeasible to find any m where H(m) = h",
                        "B": "Given m1, it's infeasible to find m2 where H(m1) = H(m2)",
                        "C": "It's infeasible to find any collision",
                        "D": "The hash is irreversible"
                    },
                    "answer": "A",
                    "points": 2,
                    "explanation": "Preimage resistance (one-way property): given hash value h, infeasible to find any message m that produces that hash."
                },
                {
                    "num": 17,
                    "question": "Collision resistance (H3) means:",
                    "options": {
                        "A": "Given m, you can't find H(m)",
                        "B": "Given m1, you can't find different m2 with same hash",
                        "C": "You can't find ANY two different messages with the same hash",
                        "D": "Hashes are unique"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Collision resistance: infeasible to find ANY pair of distinct inputs m1, m2 such that H(m1) = H(m2)."
                },
                {
                    "num": 18,
                    "question": "Which hash function is currently recommended for security-critical applications?",
                    "options": {
                        "A": "MD5",
                        "B": "SHA-1",
                        "C": "SHA-256 or SHA-3",
                        "D": "All of the above"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "SHA-256 (SHA-2 family) and SHA-3 are currently recommended. MD5 and SHA-1 are deprecated due to vulnerabilities."
                },
                {
                    "num": 19,
                    "question": "Message Authentication Codes (MAC) require:",
                    "options": {
                        "A": "Only the message as input",
                        "B": "Message and a secret key",
                        "C": "Public and private key pairs",
                        "D": "A hash function only"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "MACs are computed using both the message and a secret key shared between sender and receiver."
                },
                {
                    "num": 20,
                    "question": "Compared to digital signatures, MACs are:",
                    "options": {
                        "A": "Slower but more secure",
                        "B": "Faster but don't provide non-repudiation",
                        "C": "Less secure overall",
                        "D": "Require public key infrastructure"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "MACs use symmetric crypto (faster) but can't provide non-repudiation since the key is shared. Best for continuous data streams."
                }
            ]
        },
        
        # SECTION 2: TRUE/FALSE (1 point each)
        "section2": {
            "title": "Section 2: True/False (1 point each)",
            "questions": [
                {
                    "num": 21,
                    "question": "Encryption algorithms are typically kept secret.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Encryption algorithms are typically non-secrets (public). Security relies on the key, not algorithm secrecy."
                },
                {
                    "num": 22,
                    "question": "Computational security assumes attackers have unlimited computing resources.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Computational security assumes attackers have FIXED computational resources, making brute-force infeasible."
                },
                {
                    "num": 23,
                    "question": "The Vernam cipher (one-time pad) is perfectly secret when used correctly.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - One-time pads are perfectly secret: observing ciphertext gives no information about plaintext (except length)."
                },
                {
                    "num": 24,
                    "question": "In ECB mode, errors in one ciphertext block affect multiple plaintext blocks during decryption.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - In ECB, errors only affect the corresponding block. Errors don't propagate."
                },
                {
                    "num": 25,
                    "question": "CBC mode encryption can be parallelized.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - CBC encryption cannot be parallelized (depends on previous block). Decryption CAN be parallelized."
                },
                {
                    "num": 26,
                    "question": "CTR mode allows both parallel encryption and parallel decryption.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - CTR mode allows parallelization of both encryption and decryption since blocks are independent."
                },
                {
                    "num": 27,
                    "question": "Asymmetric encryption is generally faster than symmetric encryption.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Asymmetric encryption is much slower than symmetric, which is why hybrid encryption is commonly used."
                },
                {
                    "num": 28,
                    "question": "Digital signatures provide confidentiality for the message content.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Digital signatures provide authentication, integrity, and non-repudiation, but NOT confidentiality."
                },
                {
                    "num": 29,
                    "question": "Collision resistance (H3) implies second-preimage resistance (H2).",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - If you can't find ANY collision, you certainly can't find a collision for a specific given message."
                },
                {
                    "num": 30,
                    "question": "MD5 is currently recommended for security-critical applications.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - MD5 is widely deprecated due to collision vulnerabilities. Use SHA-256 or SHA-3 instead."
                },
                {
                    "num": 31,
                    "question": "Cryptographic hash functions are reversible transformations.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Hash functions are one-way (preimage resistant). You cannot reverse a hash to get the original message."
                },
                {
                    "num": 32,
                    "question": "For a good hash function, changing a single input bit should change about 50% of output bits.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Good hash functions exhibit avalanche effect: small input changes cause unpredictable, large output changes."
                },
                {
                    "num": 33,
                    "question": "MACs provide non-repudiation.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - MACs don't provide non-repudiation because the key is shared; either party could have created the MAC."
                },
                {
                    "num": 34,
                    "question": "MACs on their own ensure message freshness and prevent replay attacks.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - MACs verify integrity and authentication but don't prevent replay. Additional mechanisms (nonces, timestamps) are needed."
                },
                {
                    "num": 35,
                    "question": "In the RSA algorithm, the public key consists of {e, n}.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - RSA public key is PU = {e, n}, private key is PR = {d, n}, where n = pq (product of two primes)."
                },
                {
                    "num": 36,
                    "question": "Hybrid encryption uses asymmetric encryption for the entire message.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Hybrid uses asymmetric encryption only for the symmetric key, then symmetric encryption for the message payload."
                },
                {
                    "num": 37,
                    "question": "A chosen-plaintext attack is more powerful than a known-plaintext attack.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Chosen-plaintext allows attacker to choose specific plaintexts and see resulting ciphertexts, providing more control."
                },
                {
                    "num": 38,
                    "question": "AES is a block cipher with a block length of 128 bits.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - AES has a fixed block length of 128 bits and supports key lengths of 128, 192, or 256 bits."
                },
                {
                    "num": 39,
                    "question": "DES has a key length of 128 bits.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - DES has a key length of only 56 bits (too short by modern standards), which is why it was replaced by AES."
                },
                {
                    "num": 40,
                    "question": "Birthday paradox makes finding collisions easier than finding preimages.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Due to birthday paradox, collision attacks require roughly 2^(n/2) operations vs 2^n for preimage attacks on n-bit hashes."
                }
            ]
        },
        
        # SECTION 3: SHORT ANSWER (2 points each)
        "section3": {
            "title": "Section 3: Short Answer (2 points each)",
            "questions": [
                {
                    "num": 41,
                    "question": "Name TWO types of attack models where the adversary is ACTIVE (separate with comma):",
                    "answer": ["chosen-plaintext", "chosen-ciphertext", "chosen plaintext", "chosen ciphertext"],
                    "points": 2,
                    "type": "multi_text",
                    "explanation": "Active adversary attack models: Chosen-plaintext attack and Chosen-ciphertext attack. (Passive: Ciphertext-only, Known-plaintext)"
                },
                {
                    "num": 42,
                    "question": "What does AES stand for?",
                    "answer": ["advanced encryption standard", "aes"],
                    "points": 2,
                    "type": "text",
                    "explanation": "AES = Advanced Encryption Standard, the current standard symmetric encryption algorithm (Rijndael, 1998)."
                },
                {
                    "num": 43,
                    "question": "In CTR mode, what must be ensured about the IV + counter value to maintain security?",
                    "answer": ["never repeat", "never repeats", "unique", "must not repeat", "no repeat"],
                    "points": 2,
                    "type": "text",
                    "explanation": "In CTR mode, IV + i must NEVER repeat across encryptions with the same key to maintain security."
                },
                {
                    "num": 44,
                    "question": "What is the formula used in the Vernam cipher (one-time pad)?",
                    "answer": ["c = m xor k", "m xor k", "c=mâŠ•k", "xor"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Vernam cipher uses XOR: c = m âŠ• k (ciphertext = message XOR key), where key length = message length."
                },
                {
                    "num": 45,
                    "question": "Name ONE cryptographic property that hash functions must satisfy:",
                    "answer": ["preimage resistance", "one-way", "second-preimage resistance", "collision resistance", "one way"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Hash functions must satisfy: H1 (preimage/one-way), H2 (second-preimage resistance), H3 (collision resistance)."
                },
                {
                    "num": 46,
                    "question": "To verify a digital signature, whose public key do you use?",
                    "answer": ["sender", "signer", "sender's", "signer's"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Verify signature using sender's/signer's PUBLIC (verification) key. Signature created with sender's PRIVATE (signing) key."
                },
                {
                    "num": 47,
                    "question": "What type of encryption (symmetric or asymmetric) is used in MACs?",
                    "answer": ["symmetric", "secret key"],
                    "points": 2,
                    "type": "text",
                    "explanation": "MACs use symmetric encryption with a shared secret key, making them much faster than digital signatures."
                },
                {
                    "num": 48,
                    "question": "Why is ECB mode considered insecure?",
                    "answer": ["identical blocks", "same plaintext", "patterns", "identical plaintext blocks produce identical ciphertext"],
                    "points": 2,
                    "type": "text",
                    "explanation": "ECB is insecure because identical plaintext blocks produce identical ciphertext blocks, revealing patterns (e.g., ECB penguin)."
                },
                {
                    "num": 49,
                    "question": "What does IV stand for in cipher modes like CBC?",
                    "answer": ["initialization vector", "init vector"],
                    "points": 2,
                    "type": "text",
                    "explanation": "IV = Initialization Vector, a random value used to ensure different ciphertext for identical plaintext in modes like CBC."
                },
                {
                    "num": 50,
                    "question": "Information-theoretic security means security even against adversaries with _______ computing power:",
                    "answer": ["unlimited", "infinite", "unbounded", "unbound"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Information-theoretic security (like one-time pads) is secure even against adversaries with unlimited/unbounded computing power."
                }
            ]
        }
    }

def get_chapter_3_questions():
    """Returns Chapter 3 questions (User Authentication - up to slide 33)"""
    return {
        # SECTION 1: MULTIPLE CHOICE (2 points each)
        "section1": {
            "title": "Section 1: Multiple Choice (2 points each)",
            "questions": [
                {
                    "num": 1,
                    "question": "Authentication is best described as:",
                    "options": {
                        "A": "The process of granting access rights to resources",
                        "B": "The process of using supporting evidence to corroborate an asserted identity",
                        "C": "The process of encrypting user credentials",
                        "D": "The process of establishing identity without an explicit assertion"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Authentication is the process of using supporting evidence (credentials) to corroborate an asserted identity. It's a single test to verify if provided credentials match the stored template."
                },
                {
                    "num": 2,
                    "question": "Identification (recognition) differs from authentication in that:",
                    "options": {
                        "A": "It requires a password",
                        "B": "It's a one-to-many process without an explicit identity assertion",
                        "C": "It's faster than authentication",
                        "D": "It only works with biometrics"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Identification is a one-to-many process (e.g., picking out a criminal in a crowd, matching a fingerprint to its owner) without an explicit identity having been asserted first."
                },
                {
                    "num": 3,
                    "question": "Which authentication category does a password belong to?",
                    "options": {
                        "A": "What you have",
                        "B": "What you know",
                        "C": "What you are/do",
                        "D": "Where you are"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Passwords fall under 'What you know' category of authentication, along with PINs and other memorized secrets."
                },
                {
                    "num": 4,
                    "question": "Two-factor authentication (2FA) typically requires:",
                    "options": {
                        "A": "Two passwords from the same category",
                        "B": "Methods from two different authentication categories",
                        "C": "Two biometric methods",
                        "D": "Two devices"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "2FA typically requires methods from two different categories to provide independent protection (e.g., password + hardware token)."
                },
                {
                    "num": 5,
                    "question": "When storing passwords, the system should store:",
                    "options": {
                        "A": "Cleartext passwords for quick verification",
                        "B": "Password hashes H(pi)",
                        "C": "Encrypted passwords using symmetric encryption",
                        "D": "Passwords in a secure database only"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Systems should store password hashes H(pi) using a publicly known one-way hash function, not cleartext passwords which expose all passwords if the file is stolen."
                },
                {
                    "num": 6,
                    "question": "A targeted attack is:",
                    "options": {
                        "A": "An attack aimed at breaking into any account",
                        "B": "An attack specifically aimed at pre-identified users",
                        "C": "Always an online attack",
                        "D": "Less dangerous than a trawling attack"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "A targeted attack is specifically aimed at pre-identified users (often one), while trawling attacks aim to break into any account by trying many accounts (breadth-first)."
                },
                {
                    "num": 7,
                    "question": "In a pre-computed dictionary attack, the attacker:",
                    "options": {
                        "A": "Tries passwords online against the server",
                        "B": "Creates a table of (hj, wj) pairs and compares with stolen password hashes",
                        "C": "Uses social engineering only",
                        "D": "Bypasses the authentication mechanism entirely"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Pre-computed dictionary attacks involve creating a table T of pairs (hj, wj) where hj = H(wj), then comparing with stolen password file hashes to find matches."
                },
                {
                    "num": 8,
                    "question": "Password capture attacks include all EXCEPT:",
                    "options": {
                        "A": "Shoulder-surfing",
                        "B": "Keyloggers",
                        "C": "Brute-force guessing",
                        "D": "Phishing"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Password capture attacks intercept or observe passwords (shoulder-surfing, keyloggers, phishing, pharming). Brute-force guessing is a password-guessing attack, not a capture attack."
                },
                {
                    "num": 9,
                    "question": "Password composition policies primarily aim to:",
                    "options": {
                        "A": "Prevent all types of attacks",
                        "B": "Provide higher resilience to simple password-guessing attacks",
                        "C": "Protect against capture attacks",
                        "D": "Make passwords easier to remember"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Password policies (complexity requirements) only provide higher resilience to simple password-guessing attacks. They don't protect against capture attacks and users often make predictable modifications."
                },
                {
                    "num": 10,
                    "question": "Online password-guessing attacks are primarily limited by:",
                    "options": {
                        "A": "CPU power of the attacker",
                        "B": "Network bandwidth and rate limiting",
                        "C": "Password hash strength",
                        "D": "Operating system security"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Online password-guessing attacks are limited by network bandwidth and can be defended against using rate limiting (throttling), though this can lock out legitimate users."
                },
                {
                    "num": 11,
                    "question": "The purpose of password salting is to:",
                    "options": {
                        "A": "Make passwords taste better",
                        "B": "Slow down all password attacks equally",
                        "C": "Make trawling dictionary attacks harder by requiring tables for each salt value",
                        "D": "Eliminate the need for strong passwords"
                    },
                    "answer": "C",
                    "points": 2,
                    "explanation": "Password salting stores (ui, si, H(pi,si)) where si is a random salt. This makes trawling attacks harder by a factor of 2^t (requiring tables for each salt), though targeted attacks with known salt aren't slowed."
                },
                {
                    "num": 12,
                    "question": "Iterated hashing (password stretching) works by:",
                    "options": {
                        "A": "Hashing the password multiple times: H^d(pi)",
                        "B": "Using longer hash functions",
                        "C": "Adding more salt",
                        "D": "Storing multiple password hashes"
                    },
                    "answer": "A",
                    "points": 2,
                    "explanation": "Iterated hashing computes H(â€¦H(H(pi))) = H^d(pi), hashing d times. This slows attacks by factor d (e.g., d=1000), and can be adjusted as computing power increases."
                },
                {
                    "num": 13,
                    "question": "A pepper (secret salt) differs from regular salt because:",
                    "options": {
                        "A": "It uses a different hash function",
                        "B": "It is not stored and must be guessed during verification",
                        "C": "It's only used for strong passwords",
                        "D": "It's stored encrypted"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Pepper is like salt but NOT stored. System stores H(pi,ri), erases ri, then must try all possible r* values during verification until finding a match, slowing down both legitimate verification and attacks."
                },
                {
                    "num": 14,
                    "question": "User-chosen passwords typically result in:",
                    "options": {
                        "A": "Uniform distribution across password space",
                        "B": "Predictable clustering and highly skewed distribution",
                        "C": "Maximum security",
                        "D": "Random distribution"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "User-chosen passwords exhibit predictable clustering and highly skewed distributions. Attackers exploit this by trying more popular (higher probability) passwords first."
                },
                {
                    "num": 15,
                    "question": "System-assigned random passwords provide:",
                    "options": {
                        "A": "Better usability than user-chosen passwords",
                        "B": "Protection against brute-force at cost of usability",
                        "C": "Guaranteed security against all attacks",
                        "D": "Easier memorization"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "System-assigned random passwords create uniform distribution (password space b^n), making brute-force the best attack strategy, but suffer from poor usability (violates P11: User-buy-in)."
                },
                {
                    "num": 16,
                    "question": "Password denylists are used to:",
                    "options": {
                        "A": "Block users from the system",
                        "B": "Prevent selection of most-popular weak passwords",
                        "C": "Store forbidden usernames",
                        "D": "Encrypt passwords"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Denylists contain most-popular passwords from known distributions. Proactive password checking disallows passwords on the denylist during password selection."
                },
                {
                    "num": 17,
                    "question": "Which defensive measure makes a stolen password hash file less useful for offline attacks?",
                    "options": {
                        "A": "Rate limiting",
                        "B": "MAC on password hashes",
                        "C": "Account lockout",
                        "D": "CAPTCHA"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Adding a MAC to password hashes means stolen hash files become useless since attackers can't verify guesses without the MAC key. Rate limiting and lockout defend against online attacks."
                },
                {
                    "num": 18,
                    "question": "Account recovery using secret questions typically fails because:",
                    "options": {
                        "A": "Questions are too complex",
                        "B": "Answers change over time, are socially discoverable, and recovery occurs long after answers were set",
                        "C": "They're more secure than passwords",
                        "D": "Users always remember correct answers"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Secret questions fail because: recovery occurs long after answers were set, answers change over time (favorite movie), answers are vulnerable to social engineering/guessing, and users sometimes intentionally give wrong answers."
                },
                {
                    "num": 19,
                    "question": "Which is an advantage of passwords over other authentication methods?",
                    "options": {
                        "A": "They cannot be shared",
                        "B": "They're free, simple, already understood, and easy to change",
                        "C": "They provide perfect security",
                        "D": "They never need to be reset"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Password advantages: simple/understood, 'free' (no extra hardware), no physical device to carry, quick login, easy to change/recover, well-understood failure modes, no new third party trust needed, easily delegated."
                },
                {
                    "num": 20,
                    "question": "Biometric authentication is NOT appropriate for:",
                    "options": {
                        "A": "Local device unlock",
                        "B": "Remote authentication over the Internet",
                        "C": "Physical access control",
                        "D": "Airport border control"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Biometrics are non-secret and rely on trusted input channels (fingerprint isn't from a glass!), making them unsuitable for remote Internet authentication where the input channel can't be trusted."
                }
            ]
        },
        
        # SECTION 2: TRUE/FALSE (1 point each)
        "section2": {
            "title": "Section 2: True/False (1 point each)",
            "questions": [
                {
                    "num": 21,
                    "question": "Authentication and authorization are the same thing.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Authentication verifies identity ('who are you?'), while authorization determines access rights ('what can you access?'). Authentication can be a step toward authorization."
                },
                {
                    "num": 22,
                    "question": "Two-stage authentication means user-to-device authentication followed by device-to-web authentication.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Two-stage authentication refers to the process where a user first authenticates to their device, then the device authenticates to a web service."
                },
                {
                    "num": 23,
                    "question": "Storing passwords in cleartext is vulnerable to insider threats.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Cleartext passwords expose all passwords if the file is stolen and are especially vulnerable to insider threats who have system access."
                },
                {
                    "num": 24,
                    "question": "In a trawling attack, the attacker targets a specific pre-identified user.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Trawling (breadth-first) attacks aim to break into ANY account by trying many/all accounts. Targeted attacks aim at pre-identified users."
                },
                {
                    "num": 25,
                    "question": "If hi = hj in a dictionary attack, then wj is guaranteed to be the actual password pi.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Hash collisions mean wj might not be the actual password pi, but wj will WORK as the password for login since H(wj) = H(pi) = hi."
                },
                {
                    "num": 26,
                    "question": "Password composition policies provide protection against password capture attacks.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Password complexity policies do NOT protect against capture attacks (keyloggers, phishing, shoulder-surfing). They only help against simple guessing attacks."
                },
                {
                    "num": 27,
                    "question": "Rate limiting can lock out legitimate users as a side effect.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Rate limiting (throttling) can cause denial of service to legitimate users as an unintended consequence of defending against online password-guessing attacks."
                },
                {
                    "num": 28,
                    "question": "Offline password-guessing attacks are limited by network bandwidth.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Offline attacks (after stealing password file) are limited only by computational resources, not network bandwidth. Online attacks are limited by bandwidth."
                },
                {
                    "num": 29,
                    "question": "Password salting prevents targeted on-the-fly attacks when the salt is known.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Salt doesn't increase time-cost of on-the-fly targeted attacks when salt si is available (from insider or stolen file). Salt primarily defends against pre-computed trawling attacks."
                },
                {
                    "num": 30,
                    "question": "Iterated hashing should ideally be combined with salting.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Iterated hashing (password stretching) is ideally combined with salting for comprehensive defense against offline attacks."
                },
                {
                    "num": 31,
                    "question": "Password pepper (secret salt) slows down legitimate user verification.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Pepper requires the system to sequentially try all R possible values during verification, slowing both legitimate verification and attacks by factor R."
                },
                {
                    "num": 32,
                    "question": "Attackers using password distributions try more popular passwords first.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Attackers tailor guessing strategies by trying higher estimated probability (more popular) passwords first, exploiting the skewed distribution of user-chosen passwords."
                },
                {
                    "num": 33,
                    "question": "System-assigned random passwords are more usable than user-chosen passwords.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - System-assigned random passwords have poor usability (hard to remember), violating P11: User-buy-in, though they provide better security against guessing."
                },
                {
                    "num": 34,
                    "question": "Proactive password cracking involves the system trying to crack its own users' passwords.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Proactive password cracking means the system attempts to crack its own users' passwords using background computing; users with cracked passwords are notified to change them."
                },
                {
                    "num": 35,
                    "question": "Passwords are easily delegated, which is both a benefit and a security drawback.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Password delegation (to spouse/secretary) is an underrated benefit, but retraction of delegation is rarely done, creating a security drawback."
                },
                {
                    "num": 36,
                    "question": "Secret question answers should be treated as secrets like passwords.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Secret questions often fail because answers are treated casually, but they should be protected as secrets since they provide account access."
                },
                {
                    "num": 37,
                    "question": "Passwords require no trust in a new third party compared to some other authentication methods.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Passwords require no trust in third parties beyond client/server organizations. Public-key certificates, in contrast, require trusting external certificate authorities."
                },
                {
                    "num": 38,
                    "question": "Adding a MAC to password hashes makes stolen hash files useless for offline attacks.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - MAC on password hashes means attackers can't verify password guesses from a stolen hash file without the MAC secret key, rendering the file useless."
                },
                {
                    "num": 39,
                    "question": "Biometric authentication relies on characteristics being secret.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Biometrics are NON-secret. They rely on trusted input channels providing assurance the sample is 'tightly bound' to the user present (not from a glass of water!)."
                },
                {
                    "num": 40,
                    "question": "Biometric modalities include both physical and behavioral characteristics.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Biometric modalities include physical (fingerprints, facial recognition, iris, hand geometry, retinal scan) and behavioral (gait, typing rhythm, mouse patterns) characteristics."
                }
            ]
        },
        
        # SECTION 3: SHORT ANSWER (2 points each)
        "section3": {
            "title": "Section 3: Short Answer (2 points each)",
            "questions": [
                {
                    "num": 41,
                    "question": "Name TWO of the four authentication categories (separate with comma):",
                    "answer": ["what you know", "what you have", "where you are", "what you are", "what you do", "know", "have", "are", "do"],
                    "points": 2,
                    "type": "multi_text",
                    "explanation": "The four authentication categories are: What you know, What you have, Where you are, and What you are/do (biometrics - physical or behavioral)."
                },
                {
                    "num": 42,
                    "question": "What does 2FA stand for?",
                    "answer": ["two-factor authentication", "two factor authentication", "2fa", "two factor"],
                    "points": 2,
                    "type": "text",
                    "explanation": "2FA = Two-factor authentication, using two methods from different categories (both must succeed) to provide independent protection."
                },
                {
                    "num": 43,
                    "question": "When a system stores (username, H(password)), what must it do to verify a user-entered password p?",
                    "answer": ["hash", "compute hash", "h(p)", "hash the entered password", "compute h(p) and compare"],
                    "points": 2,
                    "type": "text",
                    "explanation": "The system computes H(p) for the entered password and compares it with the stored hash value to verify if they match."
                },
                {
                    "num": 44,
                    "question": "Name ONE type of password capture attack:",
                    "answer": ["shoulder-surfing", "keylogger", "phishing", "pharming", "social engineering", "middle-person", "proxy attack", "malware", "sticky note"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Password capture attacks include: shoulder-surfing, hardware/software keyloggers, client malware, proxy/middle-person attacks, phishing, social engineering, pharming, observing written passwords."
                },
                {
                    "num": 45,
                    "question": "In password salting, is the salt value si stored in cleartext or encrypted?",
                    "answer": ["cleartext", "clear text", "clear", "plaintext", "plain text", "unencrypted"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Salt si is stored in cleartext to enable verification. The system stores (ui, si, H(pi,si)) with si readable to allow computing H(p,si) for verification."
                },
                {
                    "num": 46,
                    "question": "What is the main practical limitation of one-time pads that makes them similar to password management problems?",
                    "answer": ["key distribution", "key length", "distribution", "key management", "length", "key size"],
                    "points": 2,
                    "type": "text",
                    "explanation": "One-time pads require keys as long as the message and secure key distribution, creating management problems similar to passwords (need to securely share/store the long key)."
                },
                {
                    "num": 47,
                    "question": "For an n-character password from alphabet of size b, how many possible passwords exist (password space size)?",
                    "answer": ["b^n", "bn", "b**n", "b to the n", "b raised to n"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Password space = b^n where b is alphabet size and n is password length. Expected brute-force success after b^(n-1) guesses."
                },
                {
                    "num": 48,
                    "question": "What does SSO stand for in authentication?",
                    "answer": ["single sign-on", "single sign on", "sso"],
                    "points": 2,
                    "type": "text",
                    "explanation": "SSO = Single sign-on, architecture allowing users to authenticate once and access multiple services without re-authenticating separately for each."
                },
                {
                    "num": 49,
                    "question": "In SSO systems, what are the third parties called that create authenticators from initial authentication? (Abbreviation acceptable)",
                    "answer": ["identity provider", "idp", "identity providers", "idps"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Identity Providers (IdPs) are the third parties that access credentials or create authenticators (data tokens) from initial authentication for later identity representations."
                },
                {
                    "num": 50,
                    "question": "Why are biometrics considered non-secret?",
                    "answer": ["publicly observable", "visible", "can be observed", "not secret", "non secret", "observable", "left behind"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Biometrics are non-secret because they can be publicly observed or obtained (fingerprints on glasses, face in photos). They rely on trusted input channels, not secrecy."
                }
            ]
        }
    }


def get_chapter_4_questions():
    """Returns Chapter 4 questions (Authentication Protocols and Key Establishment)"""
    return {
        # SECTION 1: MULTIPLE CHOICE (2 points each)
        "section1": {
            "title": "Section 1: Multiple Choice (2 points each)",
            "questions": [
                {
                    "num": 1,
                    "question": "Why should we not simply submit a password for authentication?",
                    "options": {
                        "A": "Because passwords are too long",
                        "B": "Because it is not fresh, you don't know who you're submitting it to, and eavesdroppers could learn it",
                        "C": "Because hashing is required first",
                        "D": "Because two-factor authentication is always needed"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Simply submitting a password fails because: it's not fresh, you don't know who you're submitting it to (mutual authentication issue), and eavesdroppers could learn it. The goal is to prove knowledge without revealing the secret."
                },
                {
                    "num": 2,
                    "question": "What is the main purpose of authentication-only protocols?",
                    "options": {
                        "A": "To establish session keys for ongoing communication",
                        "B": "To authenticate identities without establishing session keys",
                        "C": "To encrypt all network traffic",
                        "D": "To prevent all types of attacks"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Authentication-only protocols authenticate but do not establish session keys. However, this is insufficient because an adversary could wait until authentication occurs then hijack the session."
                },
                {
                    "num": 3,
                    "question": "What is the main limitation of key transport when using public keys?",
                    "options": {
                        "A": "It's too slow",
                        "B": "It fails to achieve forward secrecy",
                        "C": "It requires symmetric encryption",
                        "D": "It cannot work over networks"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Key transport by encrypting a key with the other party's public key fails to achieve forward secrecy. If the encryption key is later revealed, tapped exchanges can be decrypted."
                },
                {
                    "num": 4,
                    "question": "What does 'ephemeral' mean in the context of session keys?",
                    "options": {
                        "A": "Permanent and reusable",
                        "B": "Temporary and short-lived for a single session",
                        "C": "Encrypted with public keys",
                        "D": "Stored for backup purposes"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Ephemeral keys are temporary and short-lived, used for a single session. This keeps their value low from an attacker's resource allocation perspective, unlike long-term keys which hold higher value."
                },
                {
                    "num": 5,
                    "question": "What is the main vulnerability of unauthenticated key establishment (like basic Diffie-Hellman)?",
                    "options": {
                        "A": "It's too computationally expensive",
                        "B": "It's vulnerable to active attackers like man-in-the-middle",
                        "C": "It doesn't work with prime numbers",
                        "D": "It requires pre-shared secrets"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Unauthenticated key establishment is fine with passive adversaries but vulnerable to active ones (e.g., middle-person/MitM attacks). You could be establishing a key with a different entity than intended."
                },
                {
                    "num": 6,
                    "question": "What does authenticated key establishment ensure?",
                    "options": {
                        "A": "Only that a key is established",
                        "B": "That the party authenticated is the same party the key is shared with",
                        "C": "That passwords are never used",
                        "D": "That encryption is not needed"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Authenticated key establishment pursues both key establishment and entity authentication within one integrated protocol to ensure that the party authenticated is the same party that the key is shared with."
                },
                {
                    "num": 7,
                    "question": "Why should keys not be reused across different parties and devices?",
                    "options": {
                        "A": "It makes encryption slower",
                        "B": "The more you use keys, the more prone to exposure they become and their value increases",
                        "C": "It violates password policies",
                        "D": "It requires more memory"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "The more keys are used, the more prone to exposure they become, and their value increases (attackers willing to pour more resources). Secrets tend to 'leak' through various means like memory dumps, backups, etc."
                },
                {
                    "num": 8,
                    "question": "What is initial keying material?",
                    "options": {
                        "A": "The final session key",
                        "B": "Public or secret keys distributed during a registration phase, often out-of-band",
                        "C": "Temporary passwords",
                        "D": "Encrypted hash values"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Initial keying material (public or secret) is associated or distributed with identified parties during a registration phase, usually involving out-of-band means to establish shared secrets."
                },
                {
                    "num": 9,
                    "question": "What characterizes a strong secret versus a weak secret?",
                    "options": {
                        "A": "Strong secrets are longer than weak secrets",
                        "B": "Strong secrets are drawn from perfectly uniform random generation; weak secrets have skewed distributions",
                        "C": "Strong secrets use more encryption",
                        "D": "Weak secrets are always user-chosen"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Strong secrets are drawn from perfectly uniform randomness (probability 2^-t for t-bit key). Weak secrets have non-uniform distributions where some keys are more likely than others (e.g., user-chosen passwords)."
                },
                {
                    "num": 10,
                    "question": "In Trial 1 of authentication protocols (hashing a weak secret W), what is the main vulnerability?",
                    "options": {
                        "A": "Replay attack",
                        "B": "Offline guessing attack using H(W) as verifiable text",
                        "C": "Man-in-the-middle attack",
                        "D": "Brute force on the hash function"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Sending H(W) allows offline guessing attacks because the transmitted hash serves to identify if the guessed secret is correct by comparing hashes."
                },
                {
                    "num": 11,
                    "question": "In Trial 2 (hashing a strong secret S), what is the main attack?",
                    "options": {
                        "A": "Offline dictionary attack",
                        "B": "Replay attack - capturing and retransmitting H(S)",
                        "C": "Password cracking",
                        "D": "Session hijacking"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "A replay attack works because capturing and transmitting H(S) later suffices - the attacker never needs to learn S. This also works with weak secret W from Trial 1."
                },
                {
                    "num": 12,
                    "question": "What is a nonce?",
                    "options": {
                        "A": "A permanent identifier",
                        "B": "A random number used once",
                        "C": "A type of encryption key",
                        "D": "A hash function"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "A nonce means a random number used once. Types include: random numbers, sequence numbers, and timestamps."
                },
                {
                    "num": 13,
                    "question": "What property do timestamps provide that challenge-response does not?",
                    "options": {
                        "A": "Better security",
                        "B": "Timeliness assurance without requiring a challenge",
                        "C": "Stronger encryption",
                        "D": "Mutual authentication"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Timestamps give timeliness assurances without the challenge part of challenge-response and help enforce constraints in time-bounded protocols. However, they require time synchronization."
                },
                {
                    "num": 14,
                    "question": "What does a replay attack involve?",
                    "options": {
                        "A": "Breaking encryption",
                        "B": "Reusing a previously captured message in a later protocol run",
                        "C": "Guessing passwords",
                        "D": "Stealing private keys"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "A replay attack involves reusing a previously captured message in a later protocol run. This is why freshness and nonces are important."
                },
                {
                    "num": 15,
                    "question": "What is a reflection attack?",
                    "options": {
                        "A": "Using mirrors to intercept signals",
                        "B": "Replaying a captured message back to the originating party",
                        "C": "Encrypting data twice",
                        "D": "Reversing hash functions"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "A reflection attack involves replaying a captured message on the originating party, potentially causing them to authenticate themselves incorrectly."
                },
                {
                    "num": 16,
                    "question": "What is a relay attack?",
                    "options": {
                        "A": "Using multiple servers",
                        "B": "Forwarding a message in real time from a distinct protocol run",
                        "C": "Breaking encryption in stages",
                        "D": "Distributing keys"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "A relay attack involves forwarding a message in real time from a distinct protocol run. Example: enemy aircraft impersonating friendly one by relaying responses."
                },
                {
                    "num": 17,
                    "question": "What does the Diffie-Hellman protocol accomplish?",
                    "options": {
                        "A": "Password encryption",
                        "B": "Establishing a shared secret over a public channel with no prior contact",
                        "C": "User authentication",
                        "D": "Certificate generation"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "Diffie-Hellman (1976) allows two parties to establish a shared secret with no prior contact, no pre-shared keying material, over a channel readable by everyone. It relies on the difficulty of discrete logarithms."
                },
                {
                    "num": 18,
                    "question": "What is a generator g in the context of finite fields?",
                    "options": {
                        "A": "A random number",
                        "B": "An element where g^i (mod p) for all i generates all group elements",
                        "C": "A prime number",
                        "D": "An encryption key"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "If p is prime, a generator g exists such that g^i (mod p) for all i = [1,p-1] generates all group elements of the multiplicative group."
                },
                {
                    "num": 19,
                    "question": "What is a small subgroup attack in Diffie-Hellman?",
                    "options": {
                        "A": "Using small prime numbers",
                        "B": "Replacing exponentials with values that generate small subgroups, forcing K into a small searchable set",
                        "C": "Shortening the key length",
                        "D": "Using weak passwords"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "An attacker may replace exponentials (like g^a, g^b) with others that generate small subgroups, forcing the resulting key K into a small set that can be easily searched. Values like 0, 1, or p-1 should be ruled out."
                },
                {
                    "num": 20,
                    "question": "What is the main goal of PAKE (Password-Authenticated Key Exchange)?",
                    "options": {
                        "A": "To make passwords longer",
                        "B": "To provide authenticated key exchange using weak secrets (passwords) without providing verifiable text",
                        "C": "To eliminate the need for encryption",
                        "D": "To store passwords securely"
                    },
                    "answer": "B",
                    "points": 2,
                    "explanation": "PAKE aims to provide strong authenticated key exchange using weak secrets (passwords) while ensuring the exchange provides no verifiable text that would allow offline password guessing attacks."
                }
            ]
        },
        
        # SECTION 2: TRUE/FALSE (1 point each)
        "section2": {
            "title": "Section 2: True/False (1 point each)",
            "questions": [
                {
                    "num": 21,
                    "question": "Authentication protocols differ from user authentication because they are machine-to-machine.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Authentication protocols are machine-to-machine, whereas user authentication involves human users."
                },
                {
                    "num": 22,
                    "question": "Having a common secret is sufficient for authentication without needing a protocol.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Having a common secret is one thing, but knowing how to use it to authenticate turns out to be a different story requiring proper protocols."
                },
                {
                    "num": 23,
                    "question": "Mutual authentication is commonly used in TLS web connections where browsers authenticate to servers.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Mutual authentication is not quite used in the web (TLS). If the browser needs to be authenticated, the user gets authenticated instead."
                },
                {
                    "num": 24,
                    "question": "Authentication by itself is sufficient for securing sessions.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Authentication by itself is not enough. An adversary could wait until authentication occurs then hijack the session. After authentication, we need to agree on shared keys for the session."
                },
                {
                    "num": 25,
                    "question": "Key transport via public key encryption achieves forward secrecy.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Key transport by encrypting with the other party's public key fails to achieve forward secrecy because tapped exchanges and a later revealed encryption key compromise past sessions."
                },
                {
                    "num": 26,
                    "question": "Ephemeral keys help maintain forward secrecy if they are properly deleted after use.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Ephemeral keys provide forward secrecy if the session secrets are fresh and securely deleted (unrecoverably removed from memory) after the session."
                },
                {
                    "num": 27,
                    "question": "Unauthenticated key establishment protocols are fine with passive adversaries but vulnerable to active ones.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Unauthenticated key establishment (like basic DH) works against passive adversaries but is vulnerable to active adversaries like man-in-the-middle attackers."
                },
                {
                    "num": 28,
                    "question": "Gluing together separate key establishment and entity authentication protocols works well.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Using separate key establishment and entity authentication protocols and gluing them together ends badly. Both functions should be pursued within one integrated protocol."
                },
                {
                    "num": 29,
                    "question": "Keys used for data at rest (storage) should be backed up despite potential risks.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Keys for securing data at rest should be backed up because hardware failure could cause permanent data loss, unlike communication keys where you can just establish a new key and retransmit."
                },
                {
                    "num": 30,
                    "question": "The more a key is used, the less valuable it becomes to attackers.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - The more you use keys, the more prone to exposure they become AND the more their value increases (attackers are willing to pour more financial resources into breaking them)."
                },
                {
                    "num": 31,
                    "question": "Initial keying material is typically established through out-of-band means.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - A registration phase using out-of-band means is needed to associate or distribute initial keying material with identified parties."
                },
                {
                    "num": 32,
                    "question": "For a key of length t bits drawn from uniform randomness, the guessing probability is 2^-t.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - For a key of length t bits from perfectly uniform randomness, the probability of guessing is 2^-t and the space is 2^t."
                },
                {
                    "num": 33,
                    "question": "User-chosen passwords typically have uniform distribution across the password space.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - User-chosen passwords are weak secrets with non-uniform, highly skewed distributions. Some passwords are more likely than others."
                },
                {
                    "num": 34,
                    "question": "Sending H(W) for a weak password W is vulnerable to offline guessing attacks.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - The hash H(W) serves as verifiable text, allowing attackers to guess W offline and verify by comparing hashes."
                },
                {
                    "num": 35,
                    "question": "A replay attack can work even with strong secrets.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Replay attacks work by capturing and retransmitting authentication messages (like H(S)) without needing to learn the secret S itself."
                },
                {
                    "num": 36,
                    "question": "Sequence numbers require unpredictability like random numbers.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - In some cases uniqueness is required, not unpredictability. Sequence numbers provide uniqueness but must be monitored for overflows."
                },
                {
                    "num": 37,
                    "question": "Timestamps require time synchronization between communicating parties.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - Timestamps require time synchronization, raising questions about precision requirements, trusted time sources, and secure synchronization methods."
                },
                {
                    "num": 38,
                    "question": "A reflection attack involves replaying a message to the originating party.",
                    "answer": "T",
                    "points": 1,
                    "explanation": "TRUE - A reflection attack involves replaying a captured message on the originating party who sent it."
                },
                {
                    "num": 39,
                    "question": "Diffie-Hellman requires pre-shared keying material between parties.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - Diffie-Hellman allows establishing a shared secret with no prior contact and no pre-shared keying material."
                },
                {
                    "num": 40,
                    "question": "Basic Diffie-Hellman provides authentication by default.",
                    "answer": "F",
                    "points": 1,
                    "explanation": "FALSE - DH is unauthenticated by default. It works against passive attackers but not active ones. You could be establishing keys with a different entity."
                }
            ]
        },
        
        # SECTION 3: SHORT ANSWER (2 points each)
        "section3": {
            "title": "Section 3: Short Answer (2 points each)",
            "questions": [
                {
                    "num": 41,
                    "question": "What does it mean to 'prove knowledge of a secret without revealing it'?",
                    "answer": ["proof of knowledge", "challenge response", "zero knowledge", "cryptographic proof", "authentication without disclosure"],
                    "points": 2,
                    "type": "text",
                    "explanation": "This means demonstrating possession of a secret through cryptographic means (like challenge-response) without actually transmitting the secret itself, keeping the element of secrecy local."
                },
                {
                    "num": 42,
                    "question": "What property is lost when using key transport with public keys, where tapped exchanges and later revealed keys compromise past sessions?",
                    "answer": ["forward secrecy", "perfect forward secrecy", "pfs", "forward security"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Forward secrecy - the property that disclosure of long-term secret keys does not compromise the secrecy of earlier session keys."
                },
                {
                    "num": 43,
                    "question": "What term describes keys that are temporary and used only for a single session?",
                    "answer": ["ephemeral", "ephemeral keys", "session keys", "temporary keys", "short-lived"],
                    "points": 2,
                    "type": "text",
                    "explanation": "Ephemeral keys are temporary/short-lived and used for single sessions, helping maintain low value and supporting forward secrecy when properly deleted."
                },
                {
                    "num": 44,
                    "question": "What does PAKE stand for?",
                    "answer": ["password-authenticated key exchange", "password authenticated key exchange", "pake"],
                    "points": 2,
                    "type": "text",
                    "explanation": "PAKE = Password-Authenticated Key Exchange, protocols designed to provide authenticated key exchange using weak secrets (passwords)."
                },
                {
                    "num": 45,
                    "question": "What term describes a random number used once in authentication protocols?",
                    "answer": ["nonce", "number used once"],
                    "points": 2,
                    "type": "text",
                    "explanation": "A nonce is a number used once. Types include random numbers, sequence numbers, and timestamps."
                },
                {
                    "num": 46,
                    "question": "What attack involves reusing a previously captured message in a later protocol run?",
                    "answer": ["replay", "replay attack", "replaying"],
                    "points": 2,
                    "type": "text",
                    "explanation": "A replay attack involves capturing and reusing a previously transmitted message, which is why freshness mechanisms like nonces are essential."
                },
                {
                    "num": 47,
                    "question": "What type of attack involves forwarding a message in real time from a distinct protocol run?",
                    "answer": ["relay", "relay attack", "relaying"],
                    "points": 2,
                    "type": "text",
                    "explanation": "A relay attack forwards messages in real time from distinct protocol runs. Example: enemy aircraft relaying friendly responses."
                },
                {
                    "num": 48,
                    "question": "In Diffie-Hellman, what mathematical problem makes it hard for attackers to compute the shared secret from g^a and g^b?",
                    "answer": ["discrete logarithm", "discrete log", "discrete logarithm problem", "dlog"],
                    "points": 2,
                    "type": "text",
                    "explanation": "The discrete logarithm problem - given g^a and g^b, an attacker cannot efficiently compute a or b, and thus cannot compute g^(ab)."
                },
                {
                    "num": 49,
                    "question": "For a prime p, what term describes the set of non-zero elements [1, p-1]? (Mathematical notation acceptable)",
                    "answer": ["multiplicative group", "z*p", "z star p", "z* sub p", "multiplicative group mod p"],
                    "points": 2,
                    "type": "text",
                    "explanation": "The multiplicative group Z*_p consists of non-zero elements [1,p-1] of the finite field modulo prime p."
                },
                {
                    "num": 50,
                    
                    "question": "What property must the exchange lack to prevent offline password guessing in PAKE protocols?",
                    "answer": ["verifiable text", "verifiable", "verification", "verifiability"],
                    "points": 2,
                    "type": "text",
                    "explanation": "The exchange must provide no verifiable text - no data that allows an attacker to verify password guesses offline by checking if decryption/computation produces recognizable results."
                }
            ]
        }
    }

# ============================================================================
# Initialize chapter functions in CHAPTERS configuration
# ============================================================================
CHAPTERS[1]['function'] = get_chapter_1_questions
CHAPTERS[2]['function'] = get_chapter_2_questions
CHAPTERS[3]['function'] = get_chapter_3_questions
CHAPTERS[4]['function'] = get_chapter_4_questions

def merge_questions(*chapter_question_dicts):
    """Merge questions from multiple chapters dynamically

    Args:
        *chapter_question_dicts: Variable number of chapter question dictionaries

    Returns:
        Merged dictionary with all questions from all chapters
    """
    merged = {}

    # Collect all unique section keys from all chapters
    all_sections = set()
    for chapter_q in chapter_question_dicts:
        all_sections.update(chapter_q.keys())

    # Process each section
    for section in all_sections:
        # Get title from first chapter that has this section
        title = None
        for chapter_q in chapter_question_dicts:
            if section in chapter_q:
                title = chapter_q[section]["title"]
                break

        merged[section] = {
            "title": title,
            "questions": []
        }

        # Add questions from each chapter with appropriate numbering offset
        for chapter_q in chapter_question_dicts:
            if section in chapter_q:
                offset = len(merged[section]["questions"])
                for q in chapter_q[section]["questions"]:
                    q_copy = q.copy()
                    q_copy["num"] = q["num"] + offset
                    merged[section]["questions"].append(q_copy)

    return merged

def select_chapter():
    """Let user select which chapter(s) to be quizzed on"""
    clear_screen()
    print("=" * 80)
    print("SYSC 4810: Quiz Chapter Selection")
    print("=" * 80)
    print("\nWhich chapter(s) would you like to be quizzed on?")

    # Dynamically generate menu from CHAPTERS configuration
    chapter_nums = sorted(CHAPTERS.keys())
    all_chapters_str = ", ".join(str(ch) for ch in chapter_nums[:-1]) + f" & {chapter_nums[-1]}"
    print(f"  0) All Chapters ({all_chapters_str})")

    for chapter_num in chapter_nums:
        print(f"  {chapter_num}) {CHAPTERS[chapter_num]['title']} only")

    print("=" * 80)

    # Generate valid choices
    valid_choices = ['0'] + [str(ch) for ch in chapter_nums]
    choices_display = ", ".join(valid_choices)

    while True:
        choice = input(f"\nEnter your choice ({choices_display}): ").strip()
        if choice in valid_choices:
            return choice
        print(f"Invalid choice. Please enter {choices_display}.")

def run_quiz():
    # Chapter selection
    chapter_selection = select_chapter()

    clear_screen()
    display_header(chapter_selection)

    input("Press ENTER to begin the quiz...")
    start_time = time.time()
    time_limit = 75 * 60  #75 minutes in seconds

    # Get questions based on selection - dynamically using CHAPTERS configuration
    if chapter_selection == "0":
        # All chapters - get all chapter questions and merge them
        all_chapter_questions = []
        for chapter_num in sorted(CHAPTERS.keys()):
            chapter_func = CHAPTERS[chapter_num]['function']
            if chapter_func:
                all_chapter_questions.append(chapter_func())
        questions = merge_questions(*all_chapter_questions)
    else:
        # Single chapter
        chapter_num = int(chapter_selection)
        if chapter_num in CHAPTERS and CHAPTERS[chapter_num]['function']:
            questions = CHAPTERS[chapter_num]['function']()
    
    # Store user answers
    user_answers = {}
    score = 0
    total_points = sum(q["points"] for section in questions.values() 
                       for q in section["questions"])
    
    # Run through each section
    for section_key, section_data in questions.items():
        clear_screen()
        print("\n" + "=" * 80)
        print(section_data["title"])
        print("=" * 80 + "\n")
        
        for q in section_data["questions"]:
            # Check time
            elapsed = time.time() - start_time
            if elapsed > time_limit:
                print("\nâ° TIME'S UP! Quiz auto-submitted.")
                break

            # Show live timer before each question
            countdown_timer(int(time_limit - elapsed))
            print(f"Question {q['num']}:")
            print(f"{q['question']}")
            
            # Multiple choice or scenario questions with options
            if "options" in q:
                print()
                for key, value in q["options"].items():
                    print(f"  {key}) {value}")
                print()
                while True:
                    answer = input("Your answer: ").strip().upper()
                    if answer in q["options"].keys():
                        user_answers[q['num']] = answer
                        is_correct = (answer == q['answer'])
                        points_earned = q['points'] if is_correct else 0
                        score += points_earned
                        
                        show_feedback(
                            answer,
                            q['answer'],
                            is_correct,
                            points_earned,
                            q['points'],
                            q.get('explanation', '')
                        )
                        break
                    else:
                        print("Invalid choice. Please enter a valid option.")
            
            # True/False questions
            elif q.get('points') == 1 and section_key == "section2":
                print()
                while True:
                    answer = input("Your answer (T/F): ").strip().upper()
                    if answer in ['T', 'F']:
                        user_answers[q['num']] = answer
                        is_correct = (answer == q['answer'])
                        points_earned = q['points'] if is_correct else 0
                        score += points_earned
                        
                        show_feedback(
                            answer,
                            q['answer'],
                            is_correct,
                            points_earned,
                            q['points'],
                            q.get('explanation', '')
                        )
                        break
                    else:
                        print("Invalid choice. Please enter T or F.")
            
            # Short answer
            else:
                print()
                answer = input("Your answer: ").strip().lower()
                user_answers[q['num']] = answer
                
                # Check if answer contains any of the acceptable answers
                points_earned = 0
                if q.get('type') == 'multi_text':
                    # Check if at least 2 acceptable answers in response
                    count = sum(1 for acceptable in q['answer'] if acceptable in answer)
                    if count >= 2:
                        points_earned = q['points']
                        is_correct = True
                    elif count == 1:
                        points_earned = q['points'] / 2
                        is_correct = False
                    else:
                        is_correct = False
                    
                    score += points_earned
                    correct_display = f"Any 2 of: {', '.join(q['answer'])}"
                    show_feedback(
                        answer,
                        correct_display,
                        is_correct,
                        points_earned,
                        q['points'],
                        q.get('explanation', '')
                    )
                    
                elif q.get('type') == 'text':
                    if any(acceptable in answer for acceptable in q['answer']):
                        points_earned = q['points']
                        is_correct = True
                    else:
                        is_correct = False
                    
                    score += points_earned
                    correct_display = f"Any of: {', '.join(q['answer'])}"
                    show_feedback(
                        answer,
                        correct_display,
                        is_correct,
                        points_earned,
                        q['points'],
                        q.get('explanation', '')
                    )
        
        # Check if time expired
        elapsed = time.time() - start_time
        if elapsed > time_limit:
            break
    
    # Display results
    clear_screen()
    print("\n" + "=" * 80)
    print("QUIZ COMPLETE!")
    print("=" * 80 + "\n")
    
    elapsed_time = time.time() - start_time
    mins = int(elapsed_time // 60)
    secs = int(elapsed_time % 60)
    
    print(f"Time taken: {mins} minutes and {secs} seconds")
    print(f"\nYour Score: {score}/{total_points}")
    percentage = (score / total_points) * 100
    print(f"Percentage: {percentage:.1f}%")
    
    # Letter grade
    if percentage >= 90:
        grade = "A+"
    elif percentage >= 85:
        grade = "A"
    elif percentage >= 80:
        grade = "A-"
    elif percentage >= 77:
        grade = "B+"
    elif percentage >= 73:
        grade = "B"
    elif percentage >= 70:
        grade = "B-"
    elif percentage >= 67:
        grade = "C+"
    elif percentage >= 63:
        grade = "C"
    elif percentage >= 60:
        grade = "C-"
    elif percentage >= 57:
        grade = "D+"
    elif percentage >= 53:
        grade = "D"
    elif percentage >= 50:
        grade = "D-"
    else:
        grade = "F"
    
    print(f"Letter Grade: {grade}")
    print("\n" + "=" * 80)
    
    # Show summary
    total_questions = sum(len(section["questions"]) for section in questions.values())
    print(f"\nðŸ“Š QUIZ SUMMARY")
    print(f"Total Questions: {total_questions}")
    print(f"Points Earned: {score}/{total_points}")
    print(f"Time Used: {mins}m {secs}s of 30m")
    print("\n" + "=" * 80)



if __name__ == "__main__":
    print("\n" + "=" * 80)
    print("Welcome to SYSC 4810 Quiz System")
    print("=" * 80)
    print("\nIMPORTANT:")
    print("- You have 30 minutes to complete this quiz")
    print("- Once started, the timer cannot be paused")
    print("- No extra time will be given if you start late")
    print("- Be specific in your answers")
    print("- You will receive immediate feedback after each answer")
    print("\n" + "=" * 80)
    
    ready = input("\nAre you ready to begin? (yes/no): ").strip().lower()
    if ready in ['yes', 'y']:
        run_quiz()
    else:
        print("\nQuiz cancelled. Come back when you're ready!")